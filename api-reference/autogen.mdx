---
title: 'Core API Reference'
description: 'Complete reference for the Multisynq client-side synchronized architecture, including Model, View, Session, and more.'
---

<Note>
This page is auto-generated from the source code. Do not edit it directly. The content is sourced from the TSDoc comments in <code>multisynq-client/client/</code>.
</Note>

## `Model`

Models are synchronized objects in Multisynq.

They are automatically kept in sync for each user in the same [session](#sessionjoin)(#sessionjoin).
Models receive input by [subscribing](#modelsubscribe)(#modelsubscribe) to events published in a [View](#view).
Their output is handled by views subscribing to events [published](#modelpublish)(#modelpublish) by a model.
Models advance time by sending messages into their [future](#modelfuture)(#modelfuture).

## Instance Creation and Initialization

### Do __NOT__ create a [Model](#model) instance using `new` and<br>do __NOT__ override the `constructor`!

To __create__ a new instance, use [create()](#modelcreate)(#modelcreate), for example:
```js
this.foo = FooModel.create({answer: 123});
```
To __initialize__ an instance, override [init()](#modelinit)(#modelinit), for example:
```js
class FooModel extends Multisynq.Model {
    init(options={}) {
        this.answer = options.answer || 42;
    }
}
```
The **reason** for this is that Models are only initialized by calling `init()`
the first time the object comes into existence in the session.
After that, when joining a session, the models are deserialized from the snapshot, which
restores all properties automatically without calling `init()`. A constructor would
be called all the time, not just when starting a session.

#### `constructor`



### Properties

##### `id`



##### `sessionId`

*Identifies the shared session of all users**

(as opposed to the [viewId](#viewviewid)(#viewviewid) which identifies the non-shared views of each user).

The session id is used as "global" scope for events like [`\`"view-join"\``](#eventview-join)(#eventview-join).

See [Session.join](#sessionjoin) for how the session id is generated.

If your app has several sessions at the same time, each session id will be different.

Example
```js
this.subscribe(this.sessionId, "view-join", this.addUser);
```

##### `viewCount`

*The number of users currently in this session.**

All users in a session share the same Model (meaning all model objects) but each user has a different View
(meaning all the non-model state). This is the number of views currently sharing this model.
It increases by 1 for every [`\`"view-join"\``](#eventview-join)(#eventview-join)
and decreases by 1 for every [`\`"view-exit"\``](#eventview-exit)(#eventview-exit) event.

Example
```js
this.subscribe(this.sessionId, "view-join", this.showUsers);
this.subscribe(this.sessionId, "view-exit", this.showUsers);
showUsers() { this.publish(this.sessionId, "view-count", this.viewCount); }
```

##### `Multisynq`

make module exports accessible via any subclass

### Methods

#### `beWellKnownAs()`

Make this model globally accessible under the given name. It can be retrieved from any other model in the same session
using [wellKnownModel()](#modelwellknownmodel)(#modelwellknownmodel).

Hint: Another way to make a model well-known is to pass a name as second argument to [Model.create()]Model#create.

Example:
```js
 class FooManager extends Multisynq.Model {
     init() {
         this.beWellKnownAs("UberFoo");
     }
 }
 class Underlings extends Multisynq.Model {
     reportToManager(something) {
         this.wellKnownModel("UberFoo").report(something);
     }
 }
```

<RequestExample>
<ParamField path="name" type="string">

</ParamField>
</RequestExample>

#### `cancelFuture()`

**Cancel a previously scheduled future message**

This unschedules the invocation of a message that was scheduled with [future](#modelfuture)(#modelfuture).
It is okay to call this method even if the message was already executed or if it was never scheduled.

**Note:** as with [future](#modelfuture)(#modelfuture), the recommended form is to pass the method itself,
but you can also pass the name of the method as a string.

<RequestExample>
<ParamField path="method" type="FutureHandler">
the method (must be a method of `\`this\``)
</ParamField>
</RequestExample>

<ResponseExample>
true if the message was found and canceled, false otherwise</ResponseExample>

#### `createQFunc()`

**Create a serializable function that can be stored in the model.**

Plain functions can not be serialized because they may contain closures that can
not be introspected by the snapshot mechanism. This method creates a serializable
"QFunc" from a regular function. It can be stored in the model and called like
the original function.

The function can only access global references (like classes), *all local
references must be passed in the `\`env\`` object*. They are captured
as constants at the time the QFunc is created. Since they are constants,
re-assignments will throw an error.

In a fat-arrow function, `\`this\`` is bound to the model that called `\`createQFunc\``,
even in a different lexical scope. It is okay to call a model's `\`createQFunc\`` from
anywhere, e.g. from a view. QFuncs can be passed from view to model as arguments
in `\`publish()\`` (provided their environment is serializable).

**Warning:** Minification can change the names of local variables and functions,
but the env will still use the unminified names. You need to disable
minification for source code that creates QFuncs with env. Alternatively, you can
pass the function's source code as a string, which will not be minified.

Behind the scenes, the function is stored as a string and compiled when needed.
The env needs to be constant because the serializer would not able to capture
the values if they were allowed to change.

<RequestExample>
<ParamField path="env" type="QFuncEnv">
an object with references used by the function
</ParamField>
<ParamField path="func" type="object">
the function to be wrapped, or a string with the function's source code
</ParamField>
</RequestExample>

<ResponseExample>
a serializable function bound to the given environment</ResponseExample>

#### `destroy()`

Unsubscribes all [subscriptions](#modelsubscribe)(#modelsubscribe) this model has,
unschedules all [future](#modelfuture)(#modelfuture) messages,
and removes it from future snapshots.

Example:
```javascript
removeChild(child) {
   const index = this.children.indexOf(child);
   this.children.splice(index, 1);
   child.destroy();
}
```

#### `future()`

**Schedule a message for future execution**

Use a future message to automatically advance time in a model,
for example for animations.
The execution will be scheduled `\`tOffset\`` milliseconds into the future.
It will run at precisely `this.now() + tOffset`.

Use the form `this.future(100).methodName(args)` to schedule the execution
of `this.methodName(args)` at time `this.now() + tOffset`.

**Hint**: This would be an unusual use of `\`future()\``, but the `\`tOffset\`` given may be `\`0\``,
in which case the execution will happen asynchronously before advancing time.
This is the only way for asynchronous execution in the model since you must not
use Promises or async functions in model code (because a snapshot may happen at any time
and it would not capture those executions).

**Note:** the recommended form given above is equivalent to `\`this.future(100, "methodName", arg1, arg2)\``
but makes it more clear that "methodName" is not just a string but the name of a method of this object.
Also, this will survive minification.
Technically, it answers a [Proxy](#httpsdevelopermozillaorgdocswebjavascriptreferenceglobal_objectsproxy)(https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
that captures the name and arguments of `\`.methodName(args)\`` for later execution.

See this [tutorial]1_1_hello_world for a complete example.

Example: single invocation with two arguments
`\`\`\`
this.future(3000).say("hello", "world");
\`\`\``
Example: repeated invocation with no arguments
`\`\`\`
tick() {
    this.n++;
    this.publish(this.id, "count", {time: this.now(), count: this.n)});
    this.future(100).tick();
}
\`\`\``

<RequestExample>
<ParamField path="tOffset" type="number">
time offset in milliseconds, must be >= 0
</ParamField>
<ParamField path="method" type="FutureHandler">

</ParamField>
<ParamField path="args" type="T">

</ParamField>
</RequestExample>

<ResponseExample>
</ResponseExample>

#### `getModel()`

Look up a model in the current session given its `\`id\``.

Example:
`\`\`\`
const otherModel = this.getModel(otherId);
\`\`\``

<RequestExample>
<ParamField path="id" type="string">

</ParamField>
</RequestExample>

#### `init()`

This is called by [create()](#modelcreate)(#modelcreate) to initialize a model instance.

In your Model subclass this is the place to [subscribe](#modelsubscribe)(#modelsubscribe) to events,
or start a [future](#modelfuture)(#modelfuture) message chain.

**Note:** When your model instance is no longer needed, you must [destroy](#modeldestroy)(#modeldestroy) it.

<RequestExample>
<ParamField path="options" type="any">

</ParamField>
<ParamField path="persistentData" type="any">

</ParamField>
</RequestExample>

#### `modelOnly()`

This methods checks if it is being called from a model, and throws an Error otherwise.

Use this to protect some model code against accidentally being called from a view.

Example:
`\`\`\`
get foo() { return this._foo; }
set foo(value) { this.modelOnly(); this._foo = value; }
\`\`\``

<RequestExample>
<ParamField path="errorMessage" type="string">

</ParamField>
</RequestExample>

#### `now()`

*The model's current time**

Every [event handler](#modelsubscribe)(#modelsubscribe) and [future message](#modelfuture)(#modelfuture) is run at a precisely defined moment
in virtual model time, and time stands still while this execution is happening. That means if you were to access this.now()
in a loop, it would never answer a different value.

The unit of now is milliseconds (1/1000 second) but the value can be fractional, it is a floating-point value.

#### `persistSession()`



<RequestExample>
<ParamField path="func" type="object">

</ParamField>
</RequestExample>

#### `publish()`

**Publish an event to a scope.**

Events are the main form of communication between models and views in Multisynq.
Both models and views can publish events, and subscribe to each other's events.
Model-to-model and view-to-view subscriptions are possible, too.

See [Model.subscribe](#modelsubscribe)(#modelsubscribe)() for a discussion of **scopes** and **event names**.
Refer to [View.subscribe](#viewsubscribe)(#viewsubscribe)() for invoking event handlers *asynchronously* or *immediately*.

Optionally, you can pass some **data** along with the event.
For events published by a model, this can be any arbitrary value or object.
See View's [publish](#viewpublish)(#viewpublish) method for restrictions in passing data from a view to a model.

If you subscribe inside the model to an event that is published by the model,
the handler will be called immediately, before the publish method returns.
If you want to have it handled asynchronously, you can use a future message:
`\`this.future(0).publish("scope", "event", data)\``.

Note that there is no way of testing whether subscriptions exist or not (because models can exist independent of views).
Publishing an event that has no subscriptions is about as cheap as that test would be, so feel free to always publish,
there is very little overhead.

Example:
`\`\`\`
this.publish("something", "changed");
this.publish(this.id, "moved", this.pos);
\`\`\``

<RequestExample>
<ParamField path="scope" type="string">
see [subscribe](#modelsubscribe)(#modelsubscribe)()
</ParamField>
<ParamField path="event" type="string">
see [subscribe](#modelsubscribe)(#modelsubscribe)()
</ParamField>
<ParamField path="data" type="T">
can be any value or object
</ParamField>
</RequestExample>

#### `random()`

*Generate a synchronized pseudo-random number**

This returns a floating-point, pseudo-random number in the range 0–1 (inclusive of 0, but not 1)
with approximately uniform distribution over that range
(just like [Math.random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)).

Since the model computation is synchronized for every user on their device, the sequence of random numbers
generated must also be exactly the same for everyone. This method provides access to such a random number generator.

#### `subscribe()`

**Register an event handler for an event published to a scope.**

Both `\`scope\`` and `\`event\`` can be arbitrary strings.
Typically, the scope would select the object (or groups of objects) to respond to the event,
and the event name would select which operation to perform.

A commonly used scope is `\`this.id\`` (in a model) and `\`model.id\`` (in a view) to establish
a communication channel between a model and its corresponding view.

You can use any literal string as a global scope, or use [`\`this.sessionId\``](#modelsessionid)(#modelsessionid) for a
session-global scope (if your application supports multipe sessions at the same time).
The predefined events [`\`"view-join"\``](#view-join)(#view-join) and [`\`"view-exit"\``](#view-exit)(#view-exit)
use this session scope.

The handler must be a method of `\`this\``, e.g. `\`subscribe("scope", "event", this.methodName)\`` will schedule the
invocation of `\`this["methodName"](data)\`` whenever `\`publish("scope", "event", data)\`` is executed.

If `\`data\`` was passed to the [publish](#modelpublish)(#modelpublish) call, it will be passed as an argument to the handler method.
You can have at most one argument. To pass multiple values, pass an Object or Array containing those values.
Note that views can only pass serializable data to models, because those events are routed via a reflector server
(see [View.publish](#viewpublish)(#viewpublish)).

Example:
`\`\`\`
this.subscribe("something", "changed", this.update);
this.subscribe(this.id, "moved", this.handleMove);
\`\`\``
Example:
`\`\`\`
class MyModel extends Multisynq.Model {
  init() {
    this.subscribe(this.id, "moved", this.handleMove);
  }
  handleMove({x,y}) {
    this.x = x;
    this.y = y;
  }
}
class MyView extends Multisynq.View {
  constructor(model) {
    this.modelId = model.id;
  }
  onpointermove(evt) {
     const x = evt.x;
     const y = evt.y;
     this.publish(this.modelId, "moved", {x,y});
  }
}
\`\`\``

<RequestExample>
<ParamField path="scope" type="string">
the event scope (to distinguish between events of the same name used by different objects)
</ParamField>
<ParamField path="event" type="string">
the event name (user-defined or system-defined)
</ParamField>
<ParamField path="handler" type="SubscriptionHandler">
the event handler (must be a method of `\`this\``, or the method name as string)
</ParamField>
</RequestExample>

<ResponseExample>
</ResponseExample>

#### `unsubscribe()`

Unsubscribes this model's handler for the given event in the given scope.

<RequestExample>
<ParamField path="scope" type="string">
see [subscribe](#modelsubscribe)(#modelsubscribe)
</ParamField>
<ParamField path="event" type="string">
see [subscribe](#modelsubscribe)(#modelsubscribe)
</ParamField>
<ParamField path="handler" type="SubscriptionHandler">
the event handler (if not given, all handlers for the event are removed)
</ParamField>
</RequestExample>

#### `unsubscribeAll()`

Unsubscribes all of this model's handlers for any event in any scope.

#### `wellKnownModel()`

Access a model that was registered previously using beWellKnownAs().

Note: The instance of your root Model class is automatically made well-known as `\`"modelRoot"\``
and passed to the [constructor](#viewconstructor)(#viewconstructor) of your root View during [Session.join](#sessionjoin)(#sessionjoin).

Example:
`\`\`\`
const topModel = this.wellKnownModel("modelRoot");
\`\`\``

<RequestExample>
<ParamField path="name" type="string">

</ParamField>
</RequestExample>

#### `create()`

__Create an instance of a Model subclass.__

The instance will be registered for automatical snapshotting, and is assigned an [id](#modelid)(#modelid).

Then it will call the user-defined [init()](#modelinit)(#modelinit) method to initialize the instance,
passing the [options](#options).

**Note:** When your model instance is no longer needed, you must [destroy](#modeldestroy)(#modeldestroy) it.
Otherwise it will be kept in the snapshot forever.

**Warning**: never create a Model instance using `\`new\``, or override its constructor. See [above](#model)(#model).

Example:
`\`\`\`
this.foo = FooModel.create({answer: 123});
\`\`\``

<RequestExample>
<ParamField path="this" type="T">

</ParamField>
<ParamField path="options" type="any">
option object to be passed to [init()](#modelinit)(#modelinit).
    There are no system-defined options as of now, you're free to define your own.
</ParamField>
</RequestExample>

#### `gatherClassTypes()`

Find classes inside an external library

This recursivley traverses a dummy object and gathers all object classes found.
Returns a mapping that can be returned from a Model's static `\`types()\`` method.

This can be used to gather all internal class types of a third party library
that otherwise would not be accessible to the serializer

Example: If `\`Foo\`` is a class from a third party library
  that internally create a `\`Bar\`` instance,
  this would find both classes
`\`\`\`
class Bar {}
class Foo { bar = new Bar(); }
static types() {
   const sample = new Foo();
   return this.gatherClassTypes(sample, "MyLib");
   // returns { "MyLib.Foo": Foo, "MyLib.Bar": Bar }
}
\`\`\``

<RequestExample>
<ParamField path="dummyObject" type="T">
an instance of a class from the library
</ParamField>
<ParamField path="prefix" type="string">
a prefix to add to the class names
</ParamField>
</RequestExample>

#### `register()`

__Registers this model subclass with Multisynq__

It is necessary to register all Model subclasses so the serializer can recreate their instances from a snapshot.
Also, the [session id](#sessionjoin)(#sessionjoin) is derived by hashing the source code of all registered classes.

**Important**: for the hashing to work reliably across browsers, be sure to specify `\`charset="utf-8"\`` for your `\`<html>\`` or all `\`<script>\`` tags.

Example
`\`\`\`
class MyModel extends Multisynq.Model {
  ...
}
MyModel.register("MyModel")
\`\`\``

<RequestExample>
<ParamField path="classId" type="string">
Id for this model class. Must be unique. If you use the same class name in two files, use e.g. `\`"file1/MyModel"\`` and `\`"file2/MyModel"\``.
</ParamField>
</RequestExample>

#### `types()`

__Static declaration of how to serialize non-model classes.__

The Multisynq snapshot mechanism only knows about [Model](#model) subclasses.
If you want to store instances of non-model classes in your model, override this method.

`\`types()\`` needs to return an Object that maps _names_ to _class descriptions_:
- the name can be any string, it just has to be unique within your app
- the class description can either be just the class itself (if the serializer should
  snapshot all its fields, see first example below), or an object with `\`write()\`` and `\`read()\`` methods to
  convert instances from and to their serializable form (see second example below).
- the serialized form answered by `\`write()\`` can be almost anything. E.g. if it answers an Array of objects
  then the serializer will be called for each of those objects. Conversely, these objects will be deserialized
  before passing the Array to `\`read()\``.

The types only need to be declared once, even if several different Model subclasses are using them.

__NOTE:__ This is currently the only way to customize serialization (for example to keep snapshots fast and small).
The serialization of Model subclasses themselves can not be customized.

Example: To use the default serializer just declare the class:</caption>
`\`\`\`
class MyModel extends Multisynq.Model {
  static types() {
    return {
      "SomeUniqueName": MyNonModelClass,
      "THREE.Vector3": THREE.Vector3,        // serialized as '{"x":...,"y":...,"z":...}'
      "THREE.Quaternion": THREE.Quaternion,
    };
  }
}
\`\`\``

Example: To define your own serializer, declare read and write functions:
`\`\`\`
class MyModel extends Multisynq.Model {
  static types() {
    return {
      "THREE.Vector3": {
        cls: THREE.Vector3,
        write: v => [v.x, v.y, v.z],        // serialized as '[...,...,...]' which is shorter than the default above
        read: a => new THREE.Vector3(a[0], a[1], a[2]),
      },
      "THREE.Color": {
        cls: THREE.Color,
        write: color => '#' + color.getHexString(),
        read: state => new THREE.Color(state),
      },
    };
  }
}
\`\`\``

#### `wellKnownModel()`

Static version of [wellKnownModel()](#modelwellknownmodel)(#modelwellknownmodel) for currently executing model.

This can be used to emulate static accessors, e.g. for lazy initialization.

__WARNING!__ Do not store the result in a static variable.
Like any global state, that can lead to divergence.

Will throw an error if called from outside model code.

Example:
`\`\`\`
static get Default() {
    let default = this.wellKnownModel("DefaultModel");
    if (!default) {
        console.log("Creating default")
        default = MyModel.create();
        default.beWellKnownAs("DefaultModel");
    }
    return default;
}
\`\`\``

<RequestExample>
<ParamField path="name" type="string">

</ParamField>
</RequestExample>



---

## `PubSubParticipant`

#### `constructor`



### Methods

#### `publish()`



<RequestExample>
<ParamField path="scope" type="string">

</ParamField>
<ParamField path="event" type="string">

</ParamField>
<ParamField path="data" type="T">

</ParamField>
</RequestExample>

#### `subscribe()`



<RequestExample>
<ParamField path="scope" type="string">

</ParamField>
<ParamField path="event" type="object">

</ParamField>
<ParamField path="handler" type="SubscriptionHandler">

</ParamField>
</RequestExample>

#### `unsubscribe()`



<RequestExample>
<ParamField path="scope" type="string">

</ParamField>
<ParamField path="event" type="string">

</ParamField>
<ParamField path="handler" type="SubscriptionHandler">

</ParamField>
</RequestExample>

#### `unsubscribeAll()`





---

## `View`

#### `constructor`

A View instance is created in [Session.join](#sessionjoin), and the root model is passed into its constructor.

This inherited constructor does not use the model in any way.
Your constructor should recreate the view state to exactly match what is in the model.
It should also [subscribe](#viewsubscribe)(#viewsubscribe) to any changes published by the model.
Typically, a view would also subscribe to the browser's or framework's input events,
and in response [publish](#viewpublish)(#viewpublish) events for the model to consume.

The constructor will, however, register the view and assign it an [id]View#id.

**Note:** When your view instance is no longer needed, you must [detach](#viewdetach)(#viewdetach) it.
Otherwise it will be kept in memory forever.

<RequestExample>
<ParamField path="model" type="Model">
the view's model
</ParamField>
</RequestExample>

### Properties

##### `viewId`

The ID of the view.

##### `Multisynq`

make module exports accessible via any subclass

### Methods

#### `detach()`

**Unsubscribes all [subscriptions](#viewsubscribe)(#viewsubscribe) this model has,
and removes it from the list of views**

This needs to be called when a view is no longer needed to prevent memory leaks.

Example:
`\`\`\`
removeChild(child) {
   const index = this.children.indexOf(child);
   this.children.splice(index, 1);
   child.detach();
}
\`\`\``

#### `externalNow()`

*The latest timestamp received from reflector**

Timestamps are received asynchronously from the reflector at the specified tick rate.
[Model time]{@View#now} however only advances synchronously on every iteration of the [main loop](#sessionjoin)(#sessionjoin).
Usually `\`now == externalNow\``, but if the model has not caught up yet, then `\`now < externalNow\``.

We call the difference "backlog". If the backlog is too large, Multisynq will put an overlay on the scene,
and remove it once the model simulation has caught up. The `\`"synced"\`` event is sent when that happens.

The `\`externalNow\`` value is rarely used by apps but may be useful if you need to synchronize views to real-time.

Example:
`\`\`\`
const backlog = this.externalNow() - this.now();
\`\`\``

#### `extrapolatedNow()`

**The model time extrapolated beyond latest timestamp received from reflector**

Timestamps are received asynchronously from the reflector at the specified tick rate.
In-between ticks or messages, neither [now()](#viewnow)(#viewnow) nor [externalNow()](#viewexternalnow)(#viewexternalnow) advances.
`\`extrapolatedNow\`` is `\`externalNow\`` plus the local time elapsed since that timestamp was received,
so it always advances.

`\`extrapolatedNow()\`` will always be >= `\`now()\`` and `\`externalNow()\``.
However, it is only guaranteed to be monotonous in-between time stamps received from the reflector
(there is no "smoothing" to reconcile local time with reflector time).

#### `future()`

*Schedule a message for future execution**
This method is here for symmetry with [Model.future](#modelfuture)(#modelfuture).

It simply schedules the execution using `\`window.setTimeout\``.
The only advantage to using this over setTimeout() is consistent style.

<RequestExample>
<ParamField path="tOffset" type="number">

</ParamField>
</RequestExample>

#### `now()`

*The model's current time**

This is the time of how far the model has been simulated.
Normally this corresponds roughly to real-world time, since the reflector is generating
time stamps based on real-world time.

If there is [backlog](#viewexternalnow)(#viewexternalnow) however (e.g while a newly joined user is catching up),
this time will advance much faster than real time.

The unit is milliseconds (1/1000 second) but the value can be fractional, it is a floating-point value.

Returns: the model's time in milliseconds since the first user created the session.

#### `publish()`

**Publish an event to a scope.**

Events are the main form of communication between models and views in Multisynq.
Both models and views can publish events, and subscribe to each other's events.
Model-to-model and view-to-view subscriptions are possible, too.

See [Model.subscribe](#modelsubscribe)(#modelsubscribe) for a discussion of **scopes** and **event names**.

Optionally, you can pass some **data** along with the event.
For events published by a view and received by a model,
the data needs to be serializable, because it will be sent via the reflector to all users.
For view-to-view events it can be any value or object.

Note that there is no way of testing whether subscriptions exist or not (because models can exist independent of views).
Publishing an event that has no subscriptions is about as cheap as that test would be, so feel free to always publish,
there is very little overhead.

Example:
`\`\`\`
this.publish("input", "keypressed", {key: 'A'});
this.publish(this.model.id, "move-to", this.pos);
\`\`\``

<RequestExample>
<ParamField path="scope" type="string">
see [subscribe](#modelsubscribe)(#modelsubscribe)()
</ParamField>
<ParamField path="event" type="string">
see [subscribe](#modelsubscribe)(#modelsubscribe)()
</ParamField>
<ParamField path="data" type="T">
can be any value or object (for view-to-model, must be serializable)
</ParamField>
</RequestExample>

#### `random()`

*Answers `\`Math.random()\``**

This method is here purely for symmetry with [Model.random](#modelrandom)(#modelrandom).

#### `subscribe()`

**Register an event handler for an event published to a scope.**

Both `\`scope\`` and `\`event\`` can be arbitrary strings.
Typically, the scope would select the object (or groups of objects) to respond to the event,
and the event name would select which operation to perform.

A commonly used scope is `\`this.id\`` (in a model) and `\`model.id\`` (in a view) to establish
a communication channel between a model and its corresponding view.

Unlike in a model's [subscribe](#modelsubscribe)(#modelsubscribe) method, you can specify when the event should be handled:
- **Queued:** The handler will be called on the next run of the [main loop](#sessionjoin)(#sessionjoin),
  the same number of times this event was published.
  This is useful if you need each piece of data that was passed in each [publish](#modelpublish)(#modelpublish) call.

  An example would be log entries generated in the model that the view is supposed to print.
  Even if more than one log event is published in one render frame, the view needs to receive each one.

  **`\`{ event: "name", handling: "queued" }\`` is the default.  Simply specify `\`"name"\`` instead.**

- **Once Per Frame:** The handler will be called only _once_ during the next run of the [main loop](#sessionjoin)(#sessionjoin).
  If [publish](#modelpublish)(#modelpublish) was called multiple times, the handler will only be invoked once,
  passing the data of only the last `\`publish\`` call.

  For example, a view typically would only be interested in the current position of a model to render it.
  Since rendering only happens once per frame, it should subscribe using the `\`oncePerFrame\`` option.
  The event typically would be published only once per frame anyways, however,
  while the model is catching up when joining a session, this would be fired rapidly.

  **`\`{ event: "name", handling: "oncePerFrame" }\`` is the most efficient option, you should use it whenever possible.**

- **Immediate:** The handler will be invoked _synchronously_ during the [publish](#modelpublish)(#modelpublish) call.
  This will tie the view code very closely to the model simulation, which in general is undesirable.
  However, if the view needs to know the exact state of the model at the time the event was published,
  before execution in the model proceeds, then this is the facility to allow this without having to copy model state.

  Pass `\`{event: "name", handling: "immediate"}\`` to enforce this behavior.

The `\`handler\`` can be any callback function.
Unlike a model's [handler](#modelsubscribe)(#modelsubscribe) which must be a method of that model,
a view's handler can be any function, including fat-arrow functions declared in-line.
Passing a method like in the model is allowed too, it will be bound to `\`this\`` in the subscribe call.

Example:
`\`\`\`
this.subscribe("something", "changed", this.update);
this.subscribe(this.id, {event: "moved", handling: "oncePerFrame"}, pos => this.sceneObject.setPosition(pos.x, pos.y, pos.z));
\`\`\``

<RequestExample>
<ParamField path="scope" type="string">
the event scope (to distinguish between events of the same name used by different objects)
</ParamField>
<ParamField path="eventSpec" type="object">
the event name (user-defined or system-defined), or an event handling spec object
</ParamField>
<ParamField path="callback" type="object">
the event handler (can be any function)
</ParamField>
</RequestExample>

<ResponseExample>
</ResponseExample>

<Card title="Tutorial" href="/docs/tutorials/1_4_view_smoothing">Explore the 1_4_view_smoothing tutorial to learn more.</Card>

#### `unsubscribe()`

Unsubscribes this view's handler for the given event in the given scope.

<RequestExample>
<ParamField path="scope" type="string">
see [subscribe](#viewsubscribe)(#viewsubscribe)
</ParamField>
<ParamField path="event" type="string">
see [subscribe](#viewsubscribe)(#viewsubscribe)
</ParamField>
<ParamField path="handler" type="SubscriptionHandler">
the event handler (if not given, all handlers for the event are removed)
</ParamField>
</RequestExample>

#### `unsubscribeAll()`

Unsubscribes all of this views's handlers for any event in any scope.

#### `update()`

Called on the root view from [main loop](#sessionjoin)(#sessionjoin) once per frame. Default implementation does nothing.

Override to add your own view-side input polling, rendering, etc.

If you want this to be called for other views than the root view,
you will have to call those methods from the root view's `\`update()\``.

The time received is related to the local real-world time. If you need to access the model's time, use [this.now()](#viewnow)(#viewnow).

<RequestExample>
<ParamField path="time" type="number">

</ParamField>
</RequestExample>

#### `wellKnownModel()`

Access a model that was registered previously using beWellKnownAs().

Note: The instance of your root Model class is automatically made well-known as `\`"modelRoot"\``
and passed to the [constructor](#viewconstructor)(#viewconstructor) of your root View during [Session.join](#sessionjoin)(#sessionjoin).

Example:
`\`\`\`
const topModel = this.wellKnownModel("modelRoot");
\`\`\``

<RequestExample>
<ParamField path="name" type="string">

</ParamField>
</RequestExample>



---

