## Session

<a id="session"></a>
<Note>
This class should not be instantiated directly using <code>new</code>.
</Note>
<Tabs>
<Tab title="Methods">
#### Static Methods
<AccordionGroup>
<Accordion title="join">
<CodeGroup>
```typescript
static async join(parameters: any): any
```
</CodeGroup>
<p><strong>Join a Multisynq session.</strong> Joins a session by instantiating the root model (for a new session) or resuming from a snapshot, then constructs the view root instance. The <code>appId</code> identifies each Multisynq app. It must be a globally unique identifier following the [Android convention](https://developer.android.com/studio/build/application-id), e.g. <code>"com.example.myapp"</code>. Each dot-separated segment must start with a letter, and only letters, digits, and underscores are allowed. The session <code>name</code> identifies individual sessions within an app. You can use it for example to create different sessions for different users. That is, a user in session <code>"ABC"</code> will not see a user in <code>"DEF"</code>. One simple way to create unique sessions is via <code>Multisynq.App.autoSession()</code> which will use or generate a random name in the query part (<code>?...</code>) of the current url. (If you use a constant, then all users will end up in the same session. This is what we do in some of our tutorials for simplicity, but actual apps should manage sessions.) The session <code>password</code> is used for end-to-end encryption of all data leaving the client. If your app does not need to protect user data, you will still have to provide a constant dummy password. One simple way to have individual passwords is via <code>Multisynq.App.autoPassword()</code> which will use or generate a random password in the hash part (<code>#...</code>) of the current url. A [session id]<a href="#modelsessionid">Model#sessionId</a> is created from the given session <code>name</code> and <code>options</code>, and a hash of all the [registered]<a href="#modelregister">Model.register</a> Model classes and <a href="#constants">Constants</a>. This ensures that only users running the exact same source code end up in the same session, which is a prerequisite for perfectly synchronized computation. The session id is used to connect to a reflector. If there is no ongoing session, an instance of the <code>model</code> class is [created]<a href="#modelcreate">Model.create</a> (which in turn typically creates a number of submodels). Otherwise, the previously stored [modelRoot]<a href="#modelbewellknownas">Model#beWellKnownAs</a> is deserialized from the snapshot, along with all additional models. That root model instance is passed to the [constructor]<a href="#view">View</a> of your root <code>view</code> class. The root view should set up the input and output operations of your application, and create any additional views as to match the application state as found in the models. Then the Multisynq <strong>main loop</strong> is started (unless you pass in a <code>step: "manual"</code> parameter, e.g. for WebXR, see example below). This uses [requestAnimationFrame()](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame) for continuous updating. Each step of the main loop executes in three phases: 1. <em>Simulation:</em> the models execute the events received via the reflector, and the [future messages]<a href="#modelfuture">Model#future</a> up to the latest time stamp received from the reflector. The [events]<a href="#modelpublish">Model#publish</a> generated in this phase are put in a queue for the views to consume. 2. <em>Event Processing:</em> the queued events are processed by calling the view's [event handlers]<a href="#viewsubscribe">View#subscribe</a>. The views typically use these events to modify some view state, e.g. moving a DOM element or setting some attribute of a Three.js object. 3. <em>Updating/Rendering:</em> The view root's [update()]<a href="#viewupdate">View#update</a> method is called after all the queued events have been processed. In some applications, the update method will do nothing (e.g. DOM elements are rendered after returning control to the browser). When using other UI frameworks (e.g. Three.js), this is the place to perform the actual rendering. Also, polling input and other tasks that should happen in every frame should be placed here.</p>
##### Parameters
<ParamField path="parameters" type="any" required={true}>

</ParamField>
##### Returns
<ResponseField type="any">
<p>{Promise} Promise that resolves to an object describing the session:</p>
        <pre><code>{
        <p>id,           // session id view,         // view instance step(time),   // function for &quot;manual&quot; stepping leave(),      // function for leaving the session }</code></pre> where - <code>view</code> is an instance of the supplied view class, or of Multisynq.View if no view class was given - <code>step(time)</code> should be invoked regularly if you selected <code>manual</code> stepping, to nudge it to process the latest events from the reflector or generated internally.<pre><code>The `time` argument is expected to be in milliseconds, monotonically increasing - for example, the time received by a function passed to `window.requestAnimationFrame`.</code></pre> - <code>leave()</code> is an async function for requesting immediate, permanent disconnection from the session.</p>
</ResponseField>
##### Examples
<Tabs>
  <Tab title="auto name, password, and main loop">
  ```javascript
  Multisynq.Session.join({
      apiKey: "your_api_key",                 // paste from multisynq.io/coder
      appId: "com.example.myapp",             // namespace for session names
      name: Multisynq.App.autoSession(),        // session via URL arg
      password: Multisynq.App.autoPassword(),   // password via URL arg
      model: MyRootModel,
      view: MyRootView,
      debug: ["session"],
  });
  ```
  </Tab>
  <Tab title="manual name, password, and WebXR main loop">
  ```javascript
  Multisynq.Session.join({ apiKey: "your_api_key", appId: "com.example.myapp", name: "abc", password: "password", model: MyRootModel, view: MyRootView, step: "manual"}).then(session => {
      function xrAnimFrame(time, xrFrame) {
          session.step(time);
          ...
          xrSession.requestAnimationFrame(xrAnimFrame);
      }
      xrSession.requestAnimationFrame(xrAnimFrame);
  });
  ```
  </Tab>
</Tabs>
</Accordion>
<Accordion title="join_impl">
<CodeGroup>
```typescript
static async join_impl(parameters: any): any
```
</CodeGroup>
##### Parameters
<ParamField path="parameters" type="any" required={true}>

</ParamField>
</Accordion>
<Accordion title="leave">
<CodeGroup>
```typescript
static async leave(sessionId: any): any
```
</CodeGroup>
##### Parameters
<ParamField path="sessionId" type="any" required={true}>

</ParamField>
</Accordion>
<Accordion title="thisSession">
<CodeGroup>
```typescript
static thisSession(): any
```
</CodeGroup>
</Accordion>
</AccordionGroup>
#### Instance Methods
<AccordionGroup>
<Accordion title="id">
<CodeGroup>
```typescript
id(): any
```
</CodeGroup>
<p>Session ID, generated by [Session.join]<a href="#sessionjoin">Session.join</a>. This is a unique identifier for the session, combining the session's [persistentId]<a href="#sessionpersistentid">Session.persistentId</a> and [versionId]<a href="#sessionversionid">Session.versionId</a>. It ensures that all users in a session execute the exact same Model code.</p>
</Accordion>
<Accordion title="persistentId">
<CodeGroup>
```typescript
persistentId(): any
```
</CodeGroup>
<p>Persistent ID, generated by [Session.join]<a href="#sessionjoin">Session.join</a>. This is a unique identifier for the session, which remains the same even if a new code version is deployed.</p>
</Accordion>
<Accordion title="versionId">
<CodeGroup>
```typescript
versionId(): any
```
</CodeGroup>
<p>Version ID, generated by [Session.join]<a href="#sessionjoin">Session.join</a>. This is a unique identifier for the app version independent of the session name. It is a hash of the source code of registered Model classes and Constants. Everything the Model depends on must be registered, or Constants, to ensure that all users in a session have the exact same code. Otherwise, they might diverge in their computations. /</p>
</Accordion>
<Accordion title="name">
<CodeGroup>
```typescript
name(): any
```
</CodeGroup>
<p>The session name, as given to [Session.join]<a href="#sessionjoin">Session.join</a>.</p>
</Accordion>
<Accordion title="data">
<CodeGroup>
```typescript
data(): any
```
</CodeGroup>
<p>interface to the bulk [Data API]<a href="#data">Data</a> for this session.</p>
</Accordion>
<Accordion title="step">
<CodeGroup>
```typescript
step(_time: any): any
```
</CodeGroup>
<p>Invoke this function regularly if you selected <code>"manual"</code> stepping in [Session.join]<a href="#sessionjoin">Session.join</a>.</p>
##### Parameters
<ParamField path="_time" type="any" required={true}>

</ParamField>
</Accordion>
<Accordion title="leave">
<CodeGroup>
```typescript
leave(): any
```
</CodeGroup>
<p>Leave the session. The only way back in is to invoke [Session.join()]<a href="#sessionjoin">Session.join</a> again - or reload the app.</p>
##### Returns
<ResponseField type="any">
<p>{Promise} Promise that resolves when the session was left /</p>
</ResponseField>
</Accordion>
</AccordionGroup>
</Tab>
<Tab title="Events">
#### synced
<Info>Published when the session backlog crosses a threshold. (see <a href="#viewexternalnow">View#externalNow</a> for backlog)</Info>
<p>This is a non-synchronized view-only event. If this is the main session, it also indicates that the scene was revealed (if <code>data</code> is true) or hidden behind the overlay (if <code>data</code> is false).</p>
<h5>Properties</h5>
<ResponseField>
<ResponseField name="scope" type="String">this.viewId</ResponseField>
<ResponseField name="event" type="String">"synced"</ResponseField>
<ResponseField name="data" type="Boolean">true if in sync, false if backlogged</ResponseField>
</ResponseField>
<h5>Example</h5>
<CodeGroup>
```javascript
this.subscribe(this.viewId, "synced", this.handleSynced);
```
</CodeGroup>
#### view-join
<Info>Published when a new user enters the session, or re-enters after being temporarily disconnected.</Info>
<p>This is a model-only event, meaning views can not handle it directly. The event's payload will be the joining view's <code>viewId</code>. However, if <code>viewData</code> was passed to <a href="#sessionjoin">Session.join</a>, the event payload will be an object <code>{viewId, viewData}</code>.</p>
<h5>Properties</h5>
<ResponseField>
<ResponseField name="scope" type="String">this.sessionId</ResponseField>
<ResponseField name="event" type="String">"view-join"</ResponseField>
<ResponseField name="viewId" type="String | Object">the joining user's local viewId, or an object {viewId, viewData}</ResponseField>
</ResponseField>
#### view-exit
<Info>Published when a user leaves the session, or is disconnected.</Info>
<p>This is a model-only event, meaning views can not handle it directly. This event will be published when a view tab is closed, or disconnected due to network interruption or inactivity. If <code>viewData</code> was passed to <a href="#sessionjoin">Session.join</a>, the event payload will be an object <code>{viewId, viewData}</code>.</p>
<h5>Properties</h5>
<ResponseField>
<ResponseField name="scope" type="String">this.sessionId</ResponseField>
<ResponseField name="event" type="String">"view-exit"</ResponseField>
<ResponseField name="viewId" type="String | Object">the user's viewId, or an object {viewId, viewData}</ResponseField>
</ResponseField>
</Tab>
</Tabs>