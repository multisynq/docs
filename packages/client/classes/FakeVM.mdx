---
title: 'FakeVM'
description: 'patch Math and Date */ function patchBrowser() {     // patch Math'
---

# FakeVM

patch Math and Date */ function patchBrowser() {     // patch Math.random, and the transcendentals as defined in "@multisynq/math"     if (!globalThis.MultisynqViewMath) {         // make random use CurrentVM         globalThis.MultisynqMath.random = () => CurrentVM.random();         // save all original Math properties         globalThis.MultisynqViewMath = {};         for (const [funcName, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(Math))) {             globalThis.MultisynqViewMath[funcName] = descriptor.value;         }         // we keep the original Math object but replace the methods found in MultisynqMath         // with a dispatch based on being executed in model or view code         for (const [funcName, modelFunc] of Object.entries(globalThis.MultisynqMath)) {             const viewFunc = Math[funcName];             Math[funcName] = modelFunc.length === 1                 ? arg => CurrentVM ? modelFunc(arg) : viewFunc(arg)                 : (arg1, arg2) => CurrentVM ? modelFunc(arg1, arg2) : viewFunc(arg1, arg2);         }     }     // patch Date.now to return VirtualMachine time if called from Model code     if (!globalThis.MultisynqViewDate) {         // replace the original Date constructor function but return actual Date instances         const SystemDate = globalThis.Date; // capture in closure         // warn only once         let warned = false;         function modelDateWarning(expr, value) {             if (!warned) {                 warned = true;                 // log MultisynqWarning object to give developers a stack trace                 console.warn(new MultisynqWarning(`${expr} used in Model code`));             }             return value;         }         // Date replacement         function MultisynqDate(a, b, c, d, e, f, g) {             // written this way so MultisynqDate.length === 7 per spec             const calledWithNew = this instanceof MultisynqDate; // slightly more efficient than new.target after Babel             const args = [a, b, c, d, e, f, g];             args.length = arguments.length;             if (CurrentVM) {                 // Alwys warn. Even when providing arguments, instances still use local timezone                 // TODO: write complete replacement? Don't think so.                 modelDateWarning(calledWithNew ? "new Date()" : "Date()");                 switch (arguments.length) {                     case 0: args.push(CurrentVM.time); break;                     case 1: break;                     default:                         args[0] = SystemDate.UTC(...args);                         args.length = 1;                 }             }             const instance = new SystemDate(...args);             return calledWithNew ? instance : "" + instance;         }         // implement static properties         MultisynqDate.prototype = SystemDate.prototype;         MultisynqDate.UTC = SystemDate.UTC;         MultisynqDate.now =  () => CurrentVM ? modelDateWarning("Date.now()", CurrentVM.time) : SystemDate.now();         MultisynqDate.parse = (...args) => CurrentVM ? modelDateWarning("Date.parse()", 0) : SystemDate.parse(...args);         // make original accessible         globalThis.MultisynqViewDate = SystemDate;         // switch         globalThis.Date = MultisynqDate;     } } /* QFuncs are serializable functions. They have an explicit "this" value and an environment that gets serialized along with the source. The environment is a map of variable names to values. If one of the variables references the function itself, its name is recorded in selfRef. When resuming a snapshot, the function is compiled from source in its environment. The environment is frozen to prevent modifications that would not be reflected in the closure. All environment variables are made available as constants in the compiled function. / const QFUNC = Symbol("QFUNC"); export function createQFunc(thisVal, env, fnOrSource, selfRef) {     const qFunc = new QFunc(thisVal, env, fnOrSource, selfRef);     const fn = qFunc.compile();     fn[QFUNC] = qFunc;     return fn; } function compileQFunc(source, thisVal, env, selfRef) {     // pass env into compiler func as envVar     const compilerParams = [];     const compilerArgs = [];     let thisVar, envVar, envKeys, envValues;     if (env) {         // normally thisVal is the model, but env.this overrides that         if ("this" in env) {             thisVal = env.this;             // rename env.this to an unused variant of "this"             // because "this" is a reserved word             thisVar = "_this";             while (thisVar in env) thisVar = '_' + thisVar;             env = { ...env, [thisVar]: thisVal };             delete env.this;         }         // sort env keys to ensure consistent order         envKeys = [...Object.keys(env).sort()];         envValues = [...envKeys.map(key => env[key])];         // set envVar to an unused variant of "env"         if (envKeys.length) {             envVar = "env";             while (envVar in env || envVar === selfRef) envVar = '_' + envVar;             compilerParams.push(envVar);             compilerArgs.push(envValues);         }     }     // Make Multisynq available if the word "Multisynq" is found in the source     if (source.match(/\bMultisynq\b/) && !envKeys?.includes("Multisynq")) {         compilerParams.push("Multisynq");         compilerArgs.push(Model.Multisynq);     }     // use selfRef or an unused variant of "qFunc" as fnVar     let fnVar = selfRef || "qFunc";     while (envKeys?.includes(fnVar)) fnVar = '_' + fnVar;     // now build source for compiler function     let compilerSrc = '"use strict"\n\n';     compilerSrc += '// Multisynq QFunc Compiler by Codefrau\n\n';     compilerSrc += '//////////////// Start Compiler /////////////////\n';     compilerSrc += 'try { const '; // error on undeclared variables     // destructure env as constants to prevent accidental writes     if (envKeys?.length) {         compilerSrc += `[${envKeys.join(', ')}] = ${envVar}, `;     }     // remove indent from all lines     // unless there is an odd number of backticks in any line     // this helps when debugging and also makes the source smaller     let lines = source.split('\n');     const allButFirstLine = lines.slice(1);     const minIndent = Math.min(...allButFirstLine.map(line => line.match(/^\s*/)[0].length));     if (minIndent > 0) {         const hasOddBackticks = lines.some(line => (line.match(/`/g) || []).length % 2 === 1);         if (!hasOddBackticks) {             lines = [lines[0], ...allButFirstLine.map(line => line.slice(minIndent))];             source = lines.join('\n');         }     }     // if last line is still indented, indent the first line to match     const lastLine = lines[lines.length - 1];     const lastIndent = lastLine.match(/^\s*/)[0];     if (lastIndent) source = lastIndent + source;     // compile source and store in fnVar     compilerSrc += `${fnVar} =\n`;     compilerSrc += '//////////////// Start User Code ////////////////\n\n';     compilerSrc += source;     compilerSrc += '\n\n///////////////// End User Code /////////////////\n';     // return compiled function     compilerSrc += `return ${fnVar}`;     // ... possibly bound to env.this (does not work on fat-arrow functions, see below)     if (thisVar) compilerSrc += `.bind(${thisVar})`;     compilerSrc += ' } catch (compileError) { return compileError; }\n';     compilerSrc += '///////////////// End Compiler //////////////////';     try {         // NOTE: the compiler call below establishes thisVal for fat-arrow functions         // eslint-disable-next-line no-new-func         const compiler = new Function(...compilerParams, compilerSrc);         // we just compiled the compiler, now run it to get our function         const fn = compiler.call(thisVal, ...compilerArgs);         if (fn instanceof Error) {             console.warn("rethrowing error", fn);             throw fn;         }         // done         return fn;     } catch (error) {         console.warn(`createQFunc compiling:\n\n${source}`);         throw Error(`createQFunc(): ${error.message}`);     } } class QFunc {     // public API is new QFunc(this, env, fnOrSource, undefined)     // snapshot API is new QFunc(this, env, source, selfRef)     constructor(thisVal, env, fnOrSrc, fnSelfRef) {         this.thisVal = thisVal;         // the this reference for the function (usually the model)         this.env = env;                 // the environment for the function         this.selfRef = fnSelfRef;       // env name referencing the function itself (for recursive calls)         this.source = fnOrSrc;         // new QFunc, not from snapshot         if (fnSelfRef === undefined) {             this.selfRef = "";             if (typeof fnOrSrc === "function") this.source = fnOrSrc.toString();             // if fn itself is in env, remove it and use it as selfRef instead             const keys = Object.keys(env);             for (const key of keys) {                 if (fnOrSrc === env[key]) {                     if (this.selfRef) throw Error(`createQFunc: env.${this.selfRef} and env.${key} cannot both reference the function`);                     this.selfRef = key;                 }             }             if (this.selfRef) {                 this.env = { ...env };                 delete this.env[this.selfRef];             }         }         // freeze env to prevent modifications which would not be reflected in the closure         Object.freeze(this.env);     }     compile() {         return compileQFunc(this.source, this.thisVal, this.env, this.selfRef);     } } const QFuncSpec = {     cls: QFUNC, // not a class, special-cased when writing a Function     write: ({[QFUNC]: {thisVal, env, source, selfRef}}) => [thisVal, source, selfRef, ...Object.entries(env).flat()],     read: ([thisVal, source, selfRef, ...flattenedEntries]) => {         const env = {};         for (let i = 0; i < flattenedEntries.length; i += 2) {             env[flattenedEntries[i]] = flattenedEntries[i + 1];         }         return createQFunc(thisVal, env, source, selfRef);     }     // we flatten the env object because the constructor freezes it so the deserializer can't add to it     // that's a deserializer bug }; // used to construct method prefix and for error messages ("${X} is not a method of ..."") const FUTURE_MESSAGE_HANDLER = "future message"; const CANCEL_FUTURE = "message in cancelFuture"; const SUBSCRIPTION_HANDLER = "subscription handler"; const UNSUBSCRIBE_ARGUMENT = "unsubscribe argument"; function asQFuncMethodPrefix(handler) {     return `qFunc~${handler.split(" ")[0]}~`; } const QFUNC_FUTURE_PREFIX = asQFuncMethodPrefix(FUTURE_MESSAGE_HANDLER); const QFUNC_SUBSCRIPTION_PREFIX = asQFuncMethodPrefix(SUBSCRIPTION_HANDLER); function shouldRegisterQFuncMethod(handler) {     return handler === FUTURE_MESSAGE_HANDLER || handler === SUBSCRIPTION_HANDLER; } function isQFuncFuture(methodName) {     return methodName.startsWith(QFUNC_FUTURE_PREFIX); } function handlesFuture(handler) {     return handler === FUTURE_MESSAGE_HANDLER || handler === CANCEL_FUTURE; } function asQFuncSubscription(topic) {     return `${QFUNC_SUBSCRIPTION_PREFIX}${topic}`; } function isRegisteredQFuncSubscription(methodName, topic) {     if (!methodName.startsWith(QFUNC_SUBSCRIPTION_PREFIX)) return false;     return methodName.slice(QFUNC_SUBSCRIPTION_PREFIX.length) === topic; } // this is the only place allowed to set CurrentVM function execInVM(vm, fn) {     if (CurrentVM) throw Error("VirtualMachine confusion");     if (!(vm instanceof VirtualMachine)) throw Error("not a VM: " + vm);     const previousVM = CurrentVM;     try {         CurrentVM = vm;         globalThis.MULTISYNQVM = vm;         fn();     } finally {         CurrentVM = previousVM;     } } function execOutsideVM(fn) {     if (!CurrentVM) throw Error("VirtualMachine confusion");     const previousVM = CurrentVM;     try {         CurrentVM = null;         fn();     } finally {         CurrentVM = previousVM;     } } const INITIAL_SEQ = 0xFFFFFFF0; // initial sequence number, must match reflector.js const VOTE_SUFFIX = "#__vote"; // internal, for "vote" handling; never seen by apps const REFLECTED_SUFFIX = "#reflected"; const DIVERGENCE_SUFFIX = "#divergence"; // messages invoked via reflector (encoded as single digit, not full string) const ENCODED_MESSAGES = [     "handleModelEventInModel",   // 0: the common case (triggers handlers in models and views)     "handleBundledEvents",       // 1: the case if bundled, will verify each unbundled message     // below are encoded for consistency but not directly sent to reflector     "publishFromModelOnly",      // 2: triggers handlers in models only (specifically, join/exit)     "handlePollForSnapshot",     // 3: snapshot polling     "handleTuttiResult",         // 4: processing of TUTTI     "handleTuttiDivergence",     // 5: processing of TUTTI     "handleSnapshotVote",        // 6: snapshot voting     "handlePersistVote",         // 7: persist voting     "handleModelEventInView",    // 8: view subscription for TUTTI votes (unofficial API)     "noop",                      // 9: unused (was used in convertReflectorMessage)     "handleAuditRequest",        // A: (we're counting in Base36) respond to a DePIN audit     //                           // B: ...     // must not have more than 36 to keep it single-digit (or update encode/decode) ]; // map of message names to index for encoding const ENCODE_MESSAGE = {}; for (let i = 0; i < ENCODED_MESSAGES.length; i++) {     ENCODE_MESSAGE[ENCODED_MESSAGES[i]] = i; } // minimum ms (vm time) between successive snapshot polls const SNAPSHOT_MIN_POLL_GAP = 5000; // minimum ms (vm time) between successive persistence polls const PERSIST_MIN_POLL_GAP = 25000; // bearing in mind max tick interval of 30s const persistenceDetails = new WeakMap(); // map from vm to a persistence-details object function setPersistenceCache(vm, details) { persistenceDetails.set(vm, details); } function getPersistenceCache(vm) { return persistenceDetails.get(vm); } function clearPersistenceCache(vm) { persistenceDetails.set(vm, null); } /** A fake VM is used to run bit-identical code outside of the model, e.g. for Constant init

## Methods

### Instance Methods

#### `random()`
